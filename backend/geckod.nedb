{"_id":"declarative-mixins-for-the-web","title":"Mixins as components: a lego design pattern for the web","type":"article","date":{"$$date":1439330400000},"tags":["HTML5","Web Components"],"thumbnail":"/media/images/lego.jpg","main":"<p>\r\n    A common <q>Design Pattern</q> in the mess that is Web UI's involves using\r\n    an already built jQuery functionalities. Let's imagine we have a plug-in which\r\n    colors an element on a click. The plug-in would be used in the following way:\r\n<code class = \"language javascript\">\r\n$('#my-selector').colorOnClick()\r\n</code>\r\n</p>\r\n\r\n<p>\r\n    This is incredibly messy, and not sustainable for large and complex UIs, the\r\n    reasons for which will be listed below. The movement towards\r\n    <a href = \"http://webcomponents.org/\">web components</a> is a step in the\r\n    right direction, especially with\r\n    <a href = \"https://www.polymer-project.org/1.0/\">Polymer's</a> behaviors,\r\n    <a href = \"https://angularjs.org/\">Angular's</a> directives and all the\r\n    100's of other JavaScript frameworks being developed roughly by the rate by\r\n    which boot-camps shit out JavaScript developers.\r\n    <br/>\r\n    <em>Are there any viable alternatives?</em>\r\n</p>\r\n\r\n<p>\r\n    A honorable mention is the declarative alternative proposed by\r\n    <a href = \"https://angularjs.org/\">Googlers</a>:\r\n\r\n<code class = \"language html\">\r\n&lt;div colorOnClick class=\"my-class\">&lt;/div>\r\n</code>\r\n\r\n</p>\r\n\r\n\r\n<p>\r\n    And here's a declarative alternative using composition:\r\n<code class = \"language html\">\r\n&lt;div class=\"my-class\"&gt;\r\n    &lt;colorOnClick&gt;&lt;/colorOnClick&gt;\r\n&lt;/div&gt;\r\n</code>\r\n    This is nothing new and has been\r\n    <a href = \"https://en.wikipedia.org/wiki/Component-based_software_engineering\">\r\n    used by Game Developers for ages</a>. Let's compare the two approaches and\r\n    see which one fails short. (Hint: It's the first one).\r\n</p>\r\n\r\n\r\n<h3>Binding Points</h3>\r\n\r\n<div class = \"comparison\">\r\n\r\n    <div>\r\n        <h5>Imperative</h5>\r\n        The imperative approach has <em>two binding points for each element</em>,\r\n        Firstly, each element's id must be known:\r\n<code class = \"language html\">\r\n&lt;!-- markup.html -->\r\n&lt;div id=\"div1\">&lt;/div>\r\n&lt;div id=\"div2\">&lt;/div>\r\n</code>\r\n        Then the behavior is initialized in JavaScript:\r\n<code class = \"language javascript\">\r\n// javascript.js\r\ncolorOnClick(document.querySelector('#div1'))\r\ncolorOnClick(document.querySelector('#div2'))\r\n</code>\r\n        Selecting with a class somewhat helps, but restricts the selection\r\n        to using the same parameters (plug-in options).\r\n    </div>\r\n\r\n\r\n    <div>\r\n        <h5>Declarative</h5>\r\n\r\n        The declarative approach has a <em>single binding point per instance</em>.\r\n        The behavior is nested\r\n        in the DOM element it defines. An example:\r\n\r\n<code class = \"language html\">\r\n&lt;!-- markup.html -->\r\n\r\n&lt;!-- This div will be colored blue on click -->\r\n&lt;div id=\"div1\"&gt;\r\n    &lt;colorOnClick>&lt;/colorOnClick>\r\n&lt;/div&gt;\r\n\r\n\r\n&lt;!-- Another div which will be colored -->\r\n&lt;div id=\"div2\"&gt;\r\n    &lt;colorOnClick>&lt;/colorOnClick>\r\n&lt;/div&gt;\r\n</code>\r\n    </div>\r\n\r\n</div>\r\nHaving a single binding point minimizes changes overhead and eases debugging.\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<h3>Accessing the API</h3>\r\n\r\n<div class = \"comparison\">\r\n\r\n    <div>\r\n        <h5>Imperative</h5>\r\n        An uniform access pattern isn't statically enforced.\r\n        All developers find creative ways to access their plug-ins.\r\n<code class = \"language javascript\">\r\n//javascript.js\r\n\r\nvar element = document.querySelector('#div1')\r\n\r\n// An example with jQuery's qtip.\r\nvar qtipAPI = $(element).qtip\r\n// Accessing a behavior that plays a song\r\nvar songAPI = $(element).song().getSongControls()\r\n\r\n\r\nqtipAPI('destroy') // destroy the qtip\r\nsongAPI.play() // play a song\r\n</code>\r\n            </li>\r\n        </ul>\r\n    </div>\r\n\r\n\r\n\r\n     <div>\r\n         <h5>Declarative</h5>\r\n         Accessing an interface of a behavior here is <em>uniform</em>\r\n         across all behaviors. It is also <em>semantic</em>,\r\n         as it uses the native access patterns.\r\n<code class = \"language javascript\">\r\n//javascript.js\r\n\r\nvar element = document.querySelector('#div1')\r\n\r\n// Accessing a behavior that zooms the element\r\nvar zoomAPI = element.querySelector('zoomBehaviour')\r\n// Accessing a behavior that plays a song\r\nvar songAPI = element.querySelector('songBehaviour')\r\n// Accessing a native video element\r\nvar video   = element.querySelector(\"video\")\r\n\r\n\r\nzoomAPI.zoom() // zoom\r\nsongAPI.play() // play a song\r\nvideo.play()   // play a video\r\n</code>\r\n             </li>\r\n         </ul>\r\n     </div>\r\n\r\n</div>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<h3>Server side prerendering</h3>\r\n\r\nImagine a situation, where you would like to serve users different versions /\r\nstates of the UI.\r\n\r\n<div class = \"comparison\">\r\n    <div>\r\n        <h5>Imperative</h5>\r\n        When using an imperative approach, a prerendered state is cumbersome.\r\n        The templating engine needs to render JavaScript, which has poor templating\r\n        support ans is in general plain fugly.\r\n<code class = \"language javascript\">\r\n// prerendered js\r\n// Using the {{ }} syntax for rendering server side variables\r\nvar element = ...\r\n\r\n// Initialize the functionality with server-side rendered variables\r\nmyFunctionality({{param1}}, {{param2}}, {{param3}})\r\n</code>\r\n    </div>\r\n\r\n    <div>\r\n        <h5>Declarative</h5>\r\n        Using a declarative aproach is consistent with rendering html.\r\n<code class = \"language html\">\r\n&lt;element>\r\n    &lt;my-functionality param1=\"{{param1}}\" param2=\"{{param2}}\">&lt;/my-functionality>\r\n&lt;/element>\r\n</code>\r\n    </div>\r\n</div>\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n<h3>Communication: Events</h3>\r\n\r\n<div class = \"comparison\">\r\n\r\n    <div>\r\n        <h5>Imperative</h5>\r\n        Inter-functionality communication using the most common pattern: (events)\r\n        in a imperative UI involves firing an event on the host element.\r\n<code class = \"language javascript\">\r\n// .. somewhere from within a zooming function\r\nelement.dispatchEvent(new CustomEvent('zoomed'))\r\n\r\n// somewhere someone subscribes.\r\nelem.addEventListener('zoomed', ..)\r\n</code>\r\n    </div>\r\n\r\n    <div>\r\n        <h5>Declarative</h5>\r\n        For better or for worse, the declarative approach gives the freedom to\r\n        to work with events, generated and contained within functionalities.\r\n        This is helpful if you need to tie an event to specific functionality.\r\n<code class = \"language javascript\">\r\n// .. somewhere from within a zooming behavior\r\nbehavior.dispatchEvent(new CustomEvent('zoomed'))\r\n\r\n// .. somewhere from within another zooming behavior,\r\n// which has the same parent element\r\nbehavior.dispatchEvent(new CustomEvent('zoomed'))\r\n\r\n// .. someone somewhere listens only to the first behavior\r\ndocument.querySelector('behaviour1').addEventListener('zoomed', ..)\r\n</code>\r\n    </div>\r\n"}
